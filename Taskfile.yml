# https://taskfile.dev


version: '3'

silent: true

tasks:
  default:
    cmds:
      - task --list

  start-backend:
    desc: Start the backend locally with gradle
    cmds:
      - ./gradlew :backend:bootRun

  start-frontend:
    desc: Start the frontend locally with yarn

  start:
    desc: Start full stack with Docker (prod base + local override)
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml -f docker-compose.override.yml up -d

  stop:
    desc: Stop all containers
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml -f docker-compose.override.yml down

  build-backend-image:
    desc: Builds the backend and generates a new docker image
    cmds:
      - ./gradlew :backend:buildDockerImage

  push-backend-image:
    desc: Uploads the backend image to dockerhub
    cmds:
      - ./gradlew :backend:pushDockerImage

  build-frontend:
    desc: Builds the frontend and generates a new docker image
    dir: frontend
    cmds:
      - yarn run docker:build

  # --- Release (images and remote deploy) ---
  release:backend-image:
    desc: "Build and push backend image (tags: aldoink/jocks-karaoke:backend_1.0.0)"
    cmds:
      - ./gradlew :backend:clean :backend:buildDockerImage
      - ./gradlew :backend:pushDockerImage

  release:frontend-image:
    desc: "Build and push frontend image with backend URL baked in (tag uses package.json version)"
    vars:
      BACKEND_URL: '{{.BACKEND_URL | default "https://backend.jocks-karaoke.com"}}'
      PUBLIC_URL: '{{.PUBLIC_URL | default "https://jocks-karaoke.com"}}'
    cmds:
      - |
        docker buildx create --use >/dev/null 2>&1 || true
        FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
        docker buildx build --platform linux/amd64 \
          --build-arg REACT_APP_BACKEND_URL={{.BACKEND_URL}} \
          --build-arg PUBLIC_URL={{.PUBLIC_URL}} \
          -t aldoink/jocks-karaoke:frontend_${FRONTEND_VERSION} ./frontend --push

  release:init-remote-env:
    desc: "Ensure remote deploy/.env exists with MYSQL_ROOT_PASSWORD and JWT_SECRET"
    vars:
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - |
        ssh {{.DEPLOY_USER}}@{{.DEPLOY_HOST}} 'cd ~/jocks-karaoke/deploy && [ -f .env ] || { \
          if command -v openssl >/dev/null; then \
            echo "MYSQL_ROOT_PASSWORD=$(openssl rand -hex 24)" > .env; \
            echo "JWT_SECRET=$(openssl rand -hex 32)" >> .env; \
          else \
            PW1=$(head -c 32 /dev/urandom | od -An -tx1 | tr -d " \n"); \
            PW2=$(head -c 48 /dev/urandom | od -An -tx1 | tr -d " \n"); \
            echo "MYSQL_ROOT_PASSWORD=${PW1}" > .env; \
            echo "JWT_SECRET=${PW2}" >> .env; \
          fi; \
        }'

  release:deploy:
    desc: "Pull images and restart services on the server via SSH"
    vars:
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - |
        ssh {{.DEPLOY_USER}}@{{.DEPLOY_HOST}} 'cd ~/jocks-karaoke/deploy && \
          docker compose -f docker-compose.yml pull && \
          docker compose -f docker-compose.yml up -d'

  release:all:
    desc: "Build and push both images, ensure remote env, and deploy"
    vars:
      BACKEND_URL: '{{.BACKEND_URL | default "https://backend.jocks-karaoke.com"}}'
      PUBLIC_URL: '{{.PUBLIC_URL | default "https://jocks-karaoke.com"}}'
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - task: release:backend-image
      - task: release:frontend-image
        vars:
          BACKEND_URL: "{{.BACKEND_URL}}"
          PUBLIC_URL: "{{.PUBLIC_URL}}"
      - task: release:init-remote-env
        vars:
          DEPLOY_HOST: "{{.DEPLOY_HOST}}"
          DEPLOY_USER: "{{.DEPLOY_USER}}"
      - task: release:deploy
        vars:
          DEPLOY_HOST: "{{.DEPLOY_HOST}}"
          DEPLOY_USER: "{{.DEPLOY_USER}}"

  # --- Dev Compose Convenience ---
  dev:up:
    desc: Start dev stack (build if needed)
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml -f docker-compose.override.yml up -d

  dev:down:
    desc: Stop dev stack and remove containers
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml -f docker-compose.override.yml down

  dev:logs:
    desc: Tail logs for a service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - docker compose -f docker-compose.yml -f docker-compose.override.yml logs -f ${SERVICE}

  dev:rebuild:
    desc: Force rebuild a service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service> (frontend|backend)"; exit 1; fi
      - docker compose -f docker-compose.yml -f docker-compose.override.yml rm -sf ${SERVICE}
      - docker compose -f docker-compose.yml -f docker-compose.override.yml build --no-cache ${SERVICE}
      - docker compose -f docker-compose.yml -f docker-compose.override.yml up -d ${SERVICE}

  dev:rebuild:arm64:
    desc: Rebuild a service for Apple Silicon (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - DOCKER_DEFAULT_PLATFORM=linux/arm64/v8 docker compose -f docker-compose.yml -f docker-compose.override.yml build --no-cache ${SERVICE}
      - docker compose -f docker-compose.yml -f docker-compose.override.yml up -d ${SERVICE}

  # --- Production Compose Convenience ---
  prod:up:
    desc: Start production stack (uses images only)
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml up -d

  prod:down:
    desc: Stop production stack
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml down

  prod:restart:
    desc: Restart a prod service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - docker compose -f docker-compose.yml restart ${SERVICE}

  prod:pull:
    desc: Pull latest prod images
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml pull

  test-backend:
    desc: Builds the backend and runs the tests
    cmds:
      - ./gradlew :backend:test

  test-frontend:
    desc: Runs all yarn tests for the frontend
    dir: frontend
    cmds:
      - yarn test

  start-DB:
    desc: Starts the MYSQL database
    dir: backend
    cmds:
      - docker-compose run -d --name mysql --service-ports db

  stop-DB:
    desc: Stops the MYSQL database
    dir: backend
    cmds:
      - docker stop mysql
      - docker rm mysql