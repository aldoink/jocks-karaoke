# https://taskfile.dev


version: '3'

silent: true

tasks:
  default:
    cmds:
      - task --list

  start-backend:
    desc: Start the backend locally with gradle
    cmds:
      - ./gradlew :backend:bootRun

  start-frontend:
    desc: Start the frontend locally with yarn
    # Runs CRA dev server on localhost:3000 for local-only development
    dir: frontend
    cmds:
      - yarn start

  start:
    desc: Start full dev stack via Docker (alias to dev:up)
    cmds:
      - task: dev:up

  stop:
    desc: Stop full dev stack (alias to dev:down)
    cmds:
      - task: dev:down

  build-backend-image:
    desc: Builds the backend and generates a new docker image
    cmds:
      - ./gradlew :backend:buildDockerImage

  push-backend-image:
    desc: Uploads the backend image to dockerhub
    cmds:
      - ./gradlew :backend:pushDockerImage

  build-frontend:
    desc: Builds the frontend and generates a new docker image
    dir: frontend
    cmds:
      - yarn run docker:build

  # --- Release (images and remote deploy) ---
  release:backend-image:
    desc: "Build and push backend image (tags: aldoink/jocks-karaoke:backend_1.0.0)"
    cmds:
      - ./gradlew :backend:clean :backend:buildDockerImage
      - ./gradlew :backend:pushDockerImage

  release:frontend-image:
    desc: "Build and push frontend image with backend URL baked in (tag uses package.json version)"
    vars:
      # Defaults align with single-domain model: FE calls /api and assets from /
      BACKEND_URL: '{{.BACKEND_URL | default "/api"}}'
      PUBLIC_URL: '{{.PUBLIC_URL | default "/"}}'
    cmds:
      - |
        docker buildx create --use >/dev/null 2>&1 || true
        FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
        docker buildx build --platform linux/amd64 \
          --build-arg REACT_APP_BACKEND_URL={{.BACKEND_URL}} \
          --build-arg PUBLIC_URL={{.PUBLIC_URL}} \
          -t aldoink/jocks-karaoke:frontend_${FRONTEND_VERSION} ./frontend --push

  release:init-remote-env:
    desc: "Ensure remote deploy/.env exists with MYSQL_ROOT_PASSWORD and JWT_SECRET"
    vars:
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - |
        ssh {{.DEPLOY_USER}}@{{.DEPLOY_HOST}} 'cd ~/jocks-karaoke/deploy && { \
          # Create .env with core secrets if missing
          if [ ! -f .env ]; then \
            if command -v openssl >/dev/null; then \
              echo "MYSQL_ROOT_PASSWORD=$(openssl rand -hex 24)" > .env; \
              echo "JWT_SECRET=$(openssl rand -hex 32)" >> .env; \
            else \
              PW1=$(head -c 32 /dev/urandom | od -An -tx1 | tr -d " \n"); \
              PW2=$(head -c 48 /dev/urandom | od -An -tx1 | tr -d " \n"); \
              echo "MYSQL_ROOT_PASSWORD=${PW1}" > .env; \
              echo "JWT_SECRET=${PW2}" >> .env; \
            fi; \
          fi; \
          # Ensure app DB user credentials exist
          grep -q "^MYSQL_APP_USER=" .env || echo "MYSQL_APP_USER=app" >> .env; \
          if ! grep -q "^MYSQL_APP_PASSWORD=" .env; then \
            if command -v openssl >/dev/null; then \
              echo "MYSQL_APP_PASSWORD=$(openssl rand -hex 24)" >> .env; \
            else \
              APW=$(head -c 32 /dev/urandom | od -An -tx1 | tr -d " \n"); \
              echo "MYSQL_APP_PASSWORD=${APW}" >> .env; \
            fi; \
          fi; \
        }'

  release:deploy:
    desc: "Pull images and restart services on the server via SSH"
    vars:
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - |
        ssh {{.DEPLOY_USER}}@{{.DEPLOY_HOST}} 'cd ~/jocks-karaoke/deploy && \
          docker compose -f docker-compose.yml pull && \
          docker compose -f docker-compose.yml up -d'

  release:all:
    desc: "Build and push both images, ensure remote env, and deploy"
    vars:
      BACKEND_URL: '{{.BACKEND_URL | default "/api"}}'
      PUBLIC_URL: '{{.PUBLIC_URL | default "/"}}'
      DEPLOY_HOST: '{{.DEPLOY_HOST | default "jocks-karaoke.com"}}'
      DEPLOY_USER: '{{.DEPLOY_USER | default "allister"}}'
    cmds:
      - task: release:backend-image
      - task: release:frontend-image
        vars:
          BACKEND_URL: "{{.BACKEND_URL}}"
          PUBLIC_URL: "{{.PUBLIC_URL}}"
      - task: release:init-remote-env
        vars:
          DEPLOY_HOST: "{{.DEPLOY_HOST}}"
          DEPLOY_USER: "{{.DEPLOY_USER}}"
      - task: release:deploy
        vars:
          DEPLOY_HOST: "{{.DEPLOY_HOST}}"
          DEPLOY_USER: "{{.DEPLOY_USER}}"

  # --- Dev Compose Convenience ---
  dev:up:
    desc: Start dev stack (build if needed) using docker-compose.dev.yml
    dir: deploy
    cmds:
      - docker compose -f docker-compose.dev.yml up -d

  dev:down:
    desc: Stop dev stack and remove containers using docker-compose.dev.yml
    dir: deploy
    cmds:
      - docker compose -f docker-compose.dev.yml down

  dev:logs:
    desc: Tail logs for a dev service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - docker compose -f docker-compose.dev.yml logs -f ${SERVICE}

  dev:rebuild:
    desc: Force rebuild a dev service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service> (frontend|backend)"; exit 1; fi
      - docker compose -f docker-compose.dev.yml rm -sf ${SERVICE}
      - docker compose -f docker-compose.dev.yml build --no-cache ${SERVICE}
      - docker compose -f docker-compose.dev.yml up -d ${SERVICE}

  dev:rebuild:arm64:
    desc: Rebuild a dev service for Apple Silicon (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - DOCKER_DEFAULT_PLATFORM=linux/arm64/v8 docker compose -f docker-compose.dev.yml build --no-cache ${SERVICE}
      - docker compose -f docker-compose.dev.yml up -d ${SERVICE}

  # --- Production Compose Convenience ---
  prod:up:
    desc: Start production stack (uses images only)
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml up -d

  prod:down:
    desc: Stop production stack
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml down

  prod:restart:
    desc: Restart a prod service (var SERVICE)
    dir: deploy
    cmds:
      - |
        if [ -z "${SERVICE}" ]; then echo "Set SERVICE=<service>"; exit 1; fi
      - docker compose -f docker-compose.yml restart ${SERVICE}

  prod:pull:
    desc: Pull latest prod images
    dir: deploy
    cmds:
      - docker compose -f docker-compose.yml pull

  test-backend:
    desc: Builds the backend and runs the tests
    cmds:
      - ./gradlew :backend:test

  test-frontend:
    desc: Runs all yarn tests for the frontend
    dir: frontend
    cmds:
      - yarn test